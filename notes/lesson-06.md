# Summary of "Python & FastAPI - Annotated Type for Data Validation + Metadata!" Lesson

## 1. Core Concepts

- **Annotated Parameters:** In FastAPI, handler functions can accept annotated parameters, enabling the addition of extra information beyond just the type hint. This information can be used for various purposes, including data validation and documentation.
- **`typing.Annotated`:** This type, from Python's `typing` module, allows attaching **context-specific metadata** to a type. The syntax is `Annotated[<type>, <metadata>]`, where `<metadata>` can be any Python object.
- **Metadata Interpretation:** It's crucial to understand that by itself, `Annotated` doesn't enforce any behavior. The **responsibility of interpreting the metadata lies with the specific tool or library** that encounters the annotation, such as FastAPI. If a tool doesn't have specific logic for the metadata, it will simply treat the annotation as the base type.
- **FastAPI Integration:** FastAPI leverages `Annotated` along with its own objects like **`Query`** and **`Path`** to perform **automatic data validation** on request parameters (query, path, headers, cookies).
  - For example, using `Annotated[str, Query(max_length=50)]` on a query parameter `q` tells FastAPI to validate that `q`, if provided as a string, should not exceed 50 characters.
  - Similarly, `Annotated[int, Path(title="Band ID")]` for a path parameter `band_id` adds metadata that can enhance API documentation.
- **API Documentation:** Metadata provided through `Annotated` and FastAPI's validation objects (like `Query` and `Path`) is automatically used to enhance the **API documentation** generated by tools like Redoc. This includes adding titles, descriptions, and validation constraints to the parameter specifications.
- **Custom Validation:** The lesson demonstrates how to use functions from the `typing` module like **`get_type_hints`**, **`get_origin`**, and **`get_args`** to **inspect `Annotated` types at runtime** and implement custom validation logic.
  - `get_type_hints(function, include_extras=True)` returns a dictionary of type hints, including the metadata from `Annotated` when `include_extras` is set to `True`.
  - `get_origin(type)` gets the un-parameterized version of a type (e.g., `Annotated` for `Annotated[int, (0, 100)]`).
  - `get_args(type)` gets the type arguments (e.g., `(int, (0, 100))` for `Annotated[int, (0, 100)]`).
- **Decorators for Validation:** To keep code clean and reusable, custom validation logic based on `Annotated` metadata can be encapsulated within **decorators**. This separates the validation concerns from the core function logic.

## 2. Resources

- [Python Typing](https://docs.python.org/3/library/typing.html)
- [Annotated](https://docs.python.org/3/library/typing.html#typing.Annotated)
- [FastAPI Query Parameter Annotations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)
- [StackOverflow answer](https://stackoverflow.com/questions/68454202/how-to-use-maxlen-of-typing-annotation-of-python-3-9)

## 3. Practical Steps

**Step 1: Importing `Annotated` from the `typing` module.**

```python
from typing import Annotated
```

In this lesson, `Annotated` is imported to be used for adding metadata to type hints.

**Step 2: Defining a function with a basic `Annotated` type hint.**

```python
from typing import Annotated

def double(x: Annotated[int, (0, 100)]) -> int:
    return x * 2

result = double(4)
print(result)
```

Here, the parameter `x` is annotated as an `int` with the metadata `(0, 100)`. As the lesson points out, this annotation alone doesn't perform any validation.

**Step 3: Using `Annotated` with `Query` in FastAPI for query parameter validation.**

```python
from typing import Union, Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get('/bands', response_model=list[BandWithID])
async def get_bands(
    genre: GenreURLChoices | None = None,
    q: Annotated[str | None, Query(max_length=10)] = None
) -> list[BandWithID]:
    bands_list = [BandWithID(**band) for band in bands_data]

    if genre:
        bands_list = [
            band for band in bands_list if band.genre.value.lower() == genre.value]

    if q:
        bands_list = [band for band in bands_list if q.lower()
                      in band.name.lower()]

    return bands_list
```

In this FastAPI endpoint, the query parameter `q` is annotated with `Annotated[Union[str, None], Query(max_length=10)]`. This tells FastAPI that `q` can be either a string or `None`, and if it's a string, its maximum length should be 10 characters. FastAPI automatically handles the validation based on the `Query` metadata.

**Step 4: Using `Annotated` with `Path` in FastAPI to add metadata to a path parameter.**

```python
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get('/bands/{band_id}', response_model=BandWithID, status_code=200)
async def get_band(band_id: Annotated[int, Path(title='The band ID')]) -> BandWithID:
    band = next(
        (BandWithID(**band) for band in bands_data if band['id'] == band_id),
        None
    )

    if band is None:
        raise HTTPException(status_code=404, detail='Band not found')

    return band
```

Here, the path parameter `band_id` is annotated with `Annotated[int, Path(title="The band ID")]`. The `Path` object allows adding metadata like `title`, which will be reflected in the API documentation.

**Step 5: Importing functions for inspecting `Annotated` types for custom validation.**

```python
from typing import get_type_hints, get_origin, get_args, Annotated
```

These functions from the `typing` module are used to programmatically access the type hints and metadata provided by `Annotated`.

**Step 6: Implementing custom validation logic using `get_type_hints`, `get_origin`, and `get_args` (Conceptual Example).**
The lesson demonstrates how to retrieve the type hints with extras, check if a parameter is annotated, and then extract the original type and the metadata. This allows for implementing custom checks based on the metadata. For example, to validate the range in the `double` function:

```python
from typing import get_type_hints, get_origin, get_args, Annotated


def double(x: Annotated[int, (0, 100)]) -> int:
    type_hints = get_type_hints(double, include_extras=True)
    x_hint = type_hints.get('x')

    if get_origin(x_hint) is Annotated:
        hint_type, *hint_args = get_args(x_hint)
        low, high = hint_args[0]
        if not (low <= x <= high):
            raise ValueError(
                f"x falls outside of the boundary between {low} and {high}")
    return x * 2


try:
    result = double(100)
    print(result)
except ValueError as e:
    print(e)

```

**Step 7: Creating a decorator to encapsulate custom validation logic.**

```python
from functools import wraps
from typing import get_type_hints, get_origin, get_args, Annotated


def check_value_range(func):
    @wraps(func)
    def wrapped(x):
        type_hints = get_type_hints(double, include_extras=True)
        x_hint = type_hints.get('x')

        if get_origin(x_hint) is Annotated:
            hint_type, *hint_args = get_args(x_hint)
            low, high = hint_args[0]
            if not (low <= x <= high):
                raise ValueError(
                    f"x falls outside of the boundary between {low} and {high}")

        return func(x)

    return wrapped


@check_value_range
def double(x: Annotated[int, (0, 100)]) -> int:
    return x * 2


try:
    result = double(100)
    print(result)
except ValueError as e:
    print(e)

```

This demonstrates how to create a reusable decorator `check_value_range` that can enforce validation based on the `Annotated` metadata of the decorated function's parameters.
